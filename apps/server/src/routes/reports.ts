/**
 * Report Routes
 * Handles report attachments from external analytical programs (FRAP, SPT, etc.)
 * 
 * Reports are files generated by specialized analysis tools that produce
 * HTML, PDF, CSV, Markdown, or other document formats. Examples include:
 * - FRAP2025: Fluorescence Recovery After Photobleaching analysis reports
 * - SPT2025B: Single Particle Tracking verification reports
 */

import { Router, Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import { v4 as uuid, validate as uuidValidate } from 'uuid';
import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';
import { REPORT_TYPES, REPORT_ALLOWED_EXTENSIONS } from '@eln/shared';

// Rate limiting configuration
interface RateLimitEntry {
  count: number;
  resetTime: number;
}
const rateLimitMap = new Map<string, RateLimitEntry>();
const RATE_LIMIT_WINDOW_MS = 60 * 1000;
const RATE_LIMIT_MAX_REQUESTS = 30;

function checkRateLimit(userId: string): boolean {
  const now = Date.now();
  const entry = rateLimitMap.get(userId);
  
  if (!entry || now > entry.resetTime) {
    rateLimitMap.set(userId, { count: 1, resetTime: now + RATE_LIMIT_WINDOW_MS });
    return true;
  }
  
  if (entry.count >= RATE_LIMIT_MAX_REQUESTS) {
    return false;
  }
  
  entry.count++;
  return true;
}

/**
 * Validates that a path segment is safe (no path traversal)
 */
function isValidPathSegment(segment: string): boolean {
  if (!segment) return false;
  if (!uuidValidate(segment)) return false;
  if (segment.includes('/') || segment.includes('\\') || segment.includes('..')) return false;
  return true;
}

/**
 * Safely joins paths and validates the result stays within base directory
 */
function safeJoinPath(baseDir: string, ...segments: string[]): string | null {
  const joinedPath = path.join(baseDir, ...segments);
  const resolvedBase = path.resolve(baseDir);
  const resolvedPath = path.resolve(joinedPath);
  
  if (!resolvedPath.startsWith(resolvedBase + path.sep) && resolvedPath !== resolvedBase) {
    return null;
  }
  
  return resolvedPath;
}

// Allowed MIME types for reports
const REPORT_ALLOWED_MIME_TYPES = [
  'application/pdf',
  'text/csv',
  'application/csv',
  'text/plain',
  'application/json',
  'text/html',
  'text/markdown',
  'text/x-markdown',
  'application/vnd.ms-excel',
  'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  'text/xml',
  'application/xml',
  'image/svg+xml'
];

// Max file size: 100MB for reports (may contain large datasets)
const MAX_FILE_SIZE = 100 * 1024 * 1024;

// Data directory for reports
const DATA_DIR = process.env.REPORTS_DIR || path.join(process.cwd(), 'data', 'reports');

// Ensure data directory exists
if (!fs.existsSync(DATA_DIR)) {
  fs.mkdirSync(DATA_DIR, { recursive: true });
}

/**
 * Sanitize filename to prevent directory traversal
 */
function sanitizeFilename(filename: string): string {
  return filename
    .replace(/[/\\?%*:|"<>]/g, '-')
    .replace(/\.\./g, '')
    .substring(0, 255);
}

/**
 * Get MIME type from filename extension
 */
function guessMimeType(filename: string): string {
  const ext = path.extname(filename).toLowerCase();
  const mimeMap: Record<string, string> = {
    '.pdf': 'application/pdf',
    '.csv': 'text/csv',
    '.txt': 'text/plain',
    '.json': 'application/json',
    '.html': 'text/html',
    '.htm': 'text/html',
    '.md': 'text/markdown',
    '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    '.xls': 'application/vnd.ms-excel',
    '.xml': 'application/xml',
    '.svg': 'image/svg+xml'
  };
  return mimeMap[ext] || 'application/octet-stream';
}

/**
 * Get extension from MIME type
 */
function getExtensionFromMime(mime: string): string {
  const extMap: Record<string, string> = {
    'application/pdf': '.pdf',
    'text/csv': '.csv',
    'application/csv': '.csv',
    'text/plain': '.txt',
    'application/json': '.json',
    'text/html': '.html',
    'text/markdown': '.md',
    'text/x-markdown': '.md',
    'application/vnd.ms-excel': '.xls',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': '.xlsx',
    'application/xml': '.xml',
    'text/xml': '.xml',
    'image/svg+xml': '.svg'
  };
  return extMap[mime] || '';
}

/**
 * Validate report type
 */
function isValidReportType(reportType: string): boolean {
  return REPORT_TYPES.includes(reportType as any);
}

export function createReportRoutes(prisma: PrismaClient): Router {
  const router = Router();

  /**
   * Upload a report to an experiment
   * POST /api/experiments/:experimentId/reports
   */
  router.post('/api/experiments/:experimentId/reports', async (req: Request, res: Response) => {
    const user = (req as any).user;
    const { experimentId } = req.params;
    const { filename, mime, data, reportType, notes, metadata } = req.body;

    try {
      // Rate limiting
      if (!checkRateLimit(user?.id || req.ip || 'anonymous')) {
        return res.status(429).json({ error: 'Too many requests. Please try again later.' });
      }

      // Validate experimentId format
      if (!isValidPathSegment(experimentId)) {
        return res.status(400).json({ error: 'Invalid experiment ID format' });
      }

      // Validate experiment exists and user has access
      const experiment = await prisma.experiment.findUnique({
        where: { id: experimentId }
      });

      if (!experiment) {
        return res.status(404).json({ error: 'Experiment not found' });
      }

      // Check authorization
      const canEdit = user?.role === 'manager' || user?.role === 'admin' || experiment.userId === user?.id;
      if (!canEdit) {
        return res.status(403).json({ error: 'Not authorized to add reports to this experiment' });
      }

      // Validate required fields
      if (!filename || !data) {
        return res.status(400).json({ error: 'filename and data are required' });
      }

      // Validate report type
      const type = reportType || 'custom';
      if (!isValidReportType(type)) {
        return res.status(400).json({ 
          error: `Invalid report type: ${type}`,
          validTypes: REPORT_TYPES
        });
      }

      // Validate file extension
      const ext = path.extname(filename).toLowerCase();
      if (!REPORT_ALLOWED_EXTENSIONS.includes(ext)) {
        return res.status(400).json({
          error: `File extension not allowed: ${ext}`,
          allowedExtensions: REPORT_ALLOWED_EXTENSIONS
        });
      }

      // Validate MIME type
      const mimeType = mime || guessMimeType(filename);
      if (!REPORT_ALLOWED_MIME_TYPES.includes(mimeType)) {
        return res.status(400).json({ 
          error: `File type not allowed: ${mimeType}`,
          allowedTypes: REPORT_ALLOWED_MIME_TYPES
        });
      }

      // Decode base64 data
      let fileBuffer: Buffer;
      try {
        fileBuffer = Buffer.from(data, 'base64');
      } catch {
        return res.status(400).json({ error: 'Invalid base64 data' });
      }

      // Validate file size
      if (fileBuffer.length > MAX_FILE_SIZE) {
        return res.status(400).json({ 
          error: `File too large. Maximum size is ${MAX_FILE_SIZE / (1024 * 1024)}MB` 
        });
      }

      // Generate unique filename and path
      const reportId = uuid();
      const fileExt = ext || getExtensionFromMime(mimeType);
      const safeFilename = sanitizeFilename(filename);
      const storagePath = `${experimentId}/${reportId}${fileExt}`;
      
      // Safely construct full path
      const fullPath = safeJoinPath(DATA_DIR, experimentId, `${reportId}${fileExt}`);
      if (!fullPath) {
        return res.status(400).json({ error: 'Invalid path construction' });
      }

      // Ensure experiment directory exists
      const expDir = safeJoinPath(DATA_DIR, experimentId);
      if (!expDir) {
        return res.status(400).json({ error: 'Invalid directory path' });
      }
      if (!fs.existsSync(expDir)) {
        fs.mkdirSync(expDir, { recursive: true });
      }

      // Write file to disk
      fs.writeFileSync(fullPath, fileBuffer);

      // Calculate checksum for integrity
      const checksum = crypto.createHash('sha256').update(fileBuffer).digest('hex');

      // Create database record
      const report = await prisma.report.create({
        data: {
          id: reportId,
          experimentId,
          reportType: type,
          filename: safeFilename,
          originalFilename: safeFilename,
          mime: mimeType,
          size: fileBuffer.length,
          blobPath: storagePath,
          notes: notes || null,
          metadata: metadata ? { ...metadata, checksum } : { checksum }
        }
      });

      // Log the report addition
      await prisma.changeLog.create({
        data: {
          entityType: 'report',
          entityId: reportId,
          operation: 'create',
          newValue: JSON.stringify({
            experimentId,
            reportType: type,
            filename: safeFilename,
            mime: mimeType,
            size: fileBuffer.length,
            checksum,
            uploadedBy: user?.id
          })
        }
      });

      res.status(201).json(report);
    } catch (error) {
      console.error('Report upload error:', error);
      res.status(500).json({ error: 'Failed to upload report' });
    }
  });

  /**
   * List all reports for an experiment
   * GET /api/experiments/:experimentId/reports
   */
  router.get('/api/experiments/:experimentId/reports', async (req: Request, res: Response) => {
    const user = (req as any).user;
    const { experimentId } = req.params;

    try {
      // Rate limiting
      if (!checkRateLimit(user?.id || req.ip || 'anonymous')) {
        return res.status(429).json({ error: 'Too many requests. Please try again later.' });
      }

      // Validate experimentId format
      if (!isValidPathSegment(experimentId)) {
        return res.status(400).json({ error: 'Invalid experiment ID format' });
      }

      const reports = await prisma.report.findMany({
        where: { experimentId },
        orderBy: { createdAt: 'desc' }
      });

      res.json(reports);
    } catch (error) {
      console.error('Error fetching reports:', error);
      res.status(500).json({ error: 'Failed to fetch reports' });
    }
  });

  /**
   * Get a specific report metadata
   * GET /api/reports/:id
   */
  router.get('/api/reports/:id', async (req: Request, res: Response) => {
    const user = (req as any).user;
    const { id } = req.params;

    try {
      // Rate limiting
      if (!checkRateLimit(user?.id || req.ip || 'anonymous')) {
        return res.status(429).json({ error: 'Too many requests. Please try again later.' });
      }

      // Validate ID format
      if (!uuidValidate(id)) {
        return res.status(400).json({ error: 'Invalid report ID format' });
      }

      const report = await prisma.report.findUnique({
        where: { id }
      });

      if (!report) {
        return res.status(404).json({ error: 'Report not found' });
      }

      res.json(report);
    } catch (error) {
      console.error('Error fetching report:', error);
      res.status(500).json({ error: 'Failed to fetch report' });
    }
  });

  /**
   * Download a report file
   * GET /api/reports/:id/download
   */
  router.get('/api/reports/:id/download', async (req: Request, res: Response) => {
    const user = (req as any).user;
    const { id } = req.params;

    try {
      // Rate limiting
      if (!checkRateLimit(user?.id || req.ip || 'anonymous')) {
        return res.status(429).json({ error: 'Too many requests. Please try again later.' });
      }

      // Validate ID format
      if (!uuidValidate(id)) {
        return res.status(400).json({ error: 'Invalid report ID format' });
      }

      const report = await prisma.report.findUnique({
        where: { id }
      });

      if (!report) {
        return res.status(404).json({ error: 'Report not found' });
      }

      if (!report.blobPath) {
        return res.status(404).json({ error: 'Report file not found' });
      }

      // Safely construct path from database-stored blobPath
      const pathParts = report.blobPath.split(/[/\\]/);
      const fullPath = safeJoinPath(DATA_DIR, ...pathParts);
      
      if (!fullPath) {
        return res.status(500).json({ error: 'Invalid storage path' });
      }

      if (!fs.existsSync(fullPath)) {
        return res.status(404).json({ error: 'Report file missing from storage' });
      }

      res.setHeader('Content-Type', report.mime || 'application/octet-stream');
      res.setHeader('Content-Disposition', `attachment; filename="${encodeURIComponent(report.originalFilename || report.filename)}"`);
      res.setHeader('Content-Length', report.size?.toString() || '0');

      res.sendFile(fullPath);
    } catch (error) {
      console.error('Error downloading report:', error);
      res.status(500).json({ error: 'Failed to download report' });
    }
  });

  /**
   * View a report (inline display, especially for HTML reports)
   * GET /api/reports/:id/view
   */
  router.get('/api/reports/:id/view', async (req: Request, res: Response) => {
    const user = (req as any).user;
    const { id } = req.params;

    try {
      // Rate limiting
      if (!checkRateLimit(user?.id || req.ip || 'anonymous')) {
        return res.status(429).json({ error: 'Too many requests. Please try again later.' });
      }

      // Validate ID format
      if (!uuidValidate(id)) {
        return res.status(400).json({ error: 'Invalid report ID format' });
      }

      const report = await prisma.report.findUnique({
        where: { id }
      });

      if (!report || !report.blobPath) {
        return res.status(404).json({ error: 'Report not found' });
      }

      // Safely construct path
      const pathParts = report.blobPath.split(/[/\\]/);
      const fullPath = safeJoinPath(DATA_DIR, ...pathParts);
      
      if (!fullPath || !fs.existsSync(fullPath)) {
        return res.status(404).json({ error: 'Report file missing' });
      }

      // For HTML files, serve inline
      if (report.mime === 'text/html') {
        res.setHeader('Content-Type', 'text/html; charset=utf-8');
        res.setHeader('Content-Disposition', 'inline');
      } else {
        res.setHeader('Content-Type', report.mime || 'application/octet-stream');
        res.setHeader('Content-Disposition', 'inline');
      }

      res.sendFile(fullPath);
    } catch (error) {
      console.error('Error viewing report:', error);
      res.status(500).json({ error: 'Failed to view report' });
    }
  });

  /**
   * Get report content as base64 (for embedding in UI)
   * GET /api/reports/:id/base64
   */
  router.get('/api/reports/:id/base64', async (req: Request, res: Response) => {
    const user = (req as any).user;
    const { id } = req.params;

    try {
      // Rate limiting
      if (!checkRateLimit(user?.id || req.ip || 'anonymous')) {
        return res.status(429).json({ error: 'Too many requests. Please try again later.' });
      }

      // Validate ID format
      if (!uuidValidate(id)) {
        return res.status(400).json({ error: 'Invalid report ID format' });
      }

      const report = await prisma.report.findUnique({
        where: { id }
      });

      if (!report || !report.blobPath) {
        return res.status(404).json({ error: 'Report not found' });
      }

      // Safely construct path
      const pathParts = report.blobPath.split(/[/\\]/);
      const fullPath = safeJoinPath(DATA_DIR, ...pathParts);
      
      if (!fullPath || !fs.existsSync(fullPath)) {
        return res.status(404).json({ error: 'Report file missing' });
      }

      const fileBuffer = fs.readFileSync(fullPath);
      const base64 = fileBuffer.toString('base64');

      res.json({
        ...report,
        data: base64,
        dataUrl: `data:${report.mime};base64,${base64}`
      });
    } catch (error) {
      console.error('Error fetching report:', error);
      res.status(500).json({ error: 'Failed to fetch report' });
    }
  });

  /**
   * Update report metadata (notes, type)
   * PUT /api/reports/:id
   */
  router.put('/api/reports/:id', async (req: Request, res: Response) => {
    const user = (req as any).user;
    const { id } = req.params;
    const { notes, reportType, metadata } = req.body;

    try {
      // Validate ID format
      if (!uuidValidate(id)) {
        return res.status(400).json({ error: 'Invalid report ID format' });
      }

      const report = await prisma.report.findUnique({
        where: { id },
        include: { experiment: true }
      });

      if (!report) {
        return res.status(404).json({ error: 'Report not found' });
      }

      // Check authorization
      const canEdit = user?.role === 'manager' || user?.role === 'admin' || report.experiment.userId === user?.id;
      if (!canEdit) {
        return res.status(403).json({ error: 'Not authorized to update this report' });
      }

      // Validate report type if provided
      if (reportType && !isValidReportType(reportType)) {
        return res.status(400).json({ 
          error: `Invalid report type: ${reportType}`,
          validTypes: REPORT_TYPES
        });
      }

      const updatedReport = await prisma.report.update({
        where: { id },
        data: {
          ...(notes !== undefined && { notes }),
          ...(reportType && { reportType }),
          ...(metadata && { metadata: { ...(report.metadata as any || {}), ...metadata } })
        }
      });

      // Log the update
      await prisma.changeLog.create({
        data: {
          entityType: 'report',
          entityId: id,
          operation: 'update',
          oldValue: JSON.stringify({ notes: report.notes, reportType: report.reportType }),
          newValue: JSON.stringify({ notes: updatedReport.notes, reportType: updatedReport.reportType }),
          fieldName: 'metadata'
        }
      });

      res.json(updatedReport);
    } catch (error) {
      console.error('Error updating report:', error);
      res.status(500).json({ error: 'Failed to update report' });
    }
  });

  /**
   * Delete a report
   * DELETE /api/reports/:id
   * Note: For signed experiments, deletions are not allowed (21 CFR Part 11 compliance)
   */
  router.delete('/api/reports/:id', async (req: Request, res: Response) => {
    const user = (req as any).user;
    const { id } = req.params;

    try {
      // Validate ID format
      if (!uuidValidate(id)) {
        return res.status(400).json({ error: 'Invalid report ID format' });
      }

      const report = await prisma.report.findUnique({
        where: { id },
        include: { experiment: true }
      });

      if (!report) {
        return res.status(404).json({ error: 'Report not found' });
      }

      // Check authorization
      const canDelete = user?.role === 'manager' || user?.role === 'admin' || report.experiment.userId === user?.id;
      if (!canDelete) {
        return res.status(403).json({ error: 'Not authorized to delete this report' });
      }

      // Check if experiment is signed (21 CFR Part 11 compliance)
      if (report.experiment.status === 'signed') {
        return res.status(403).json({ 
          error: 'Cannot delete reports from signed experiments. This action would violate data integrity requirements.' 
        });
      }

      // Log the deletion before removing
      await prisma.changeLog.create({
        data: {
          entityType: 'report',
          entityId: id,
          operation: 'delete',
          oldValue: JSON.stringify(report),
          newValue: JSON.stringify({ deletedBy: user?.id, deletedAt: new Date().toISOString() })
        }
      });

      // Delete from database (keep file for audit trail)
      await prisma.report.delete({
        where: { id }
      });

      res.status(204).send();
    } catch (error) {
      console.error('Error deleting report:', error);
      res.status(500).json({ error: 'Failed to delete report' });
    }
  });

  /**
   * Get reports by type across all experiments
   * GET /api/reports?type=FRAP
   */
  router.get('/api/reports', async (req: Request, res: Response) => {
    const user = (req as any).user;
    const { type, limit = '50', offset = '0' } = req.query;

    try {
      // Rate limiting
      if (!checkRateLimit(user?.id || req.ip || 'anonymous')) {
        return res.status(429).json({ error: 'Too many requests. Please try again later.' });
      }

      const where: any = {};
      
      if (type) {
        if (!isValidReportType(type as string)) {
          return res.status(400).json({ 
            error: `Invalid report type: ${type}`,
            validTypes: REPORT_TYPES
          });
        }
        where.reportType = type;
      }

      const reports = await prisma.report.findMany({
        where,
        include: {
          experiment: {
            select: { id: true, title: true, project: true }
          }
        },
        orderBy: { createdAt: 'desc' },
        take: Math.min(parseInt(limit as string, 10) || 50, 100),
        skip: parseInt(offset as string, 10) || 0
      });

      const total = await prisma.report.count({ where });

      res.json({
        reports,
        total,
        limit: parseInt(limit as string, 10),
        offset: parseInt(offset as string, 10)
      });
    } catch (error) {
      console.error('Error fetching reports:', error);
      res.status(500).json({ error: 'Failed to fetch reports' });
    }
  });

  return router;
}

export default createReportRoutes;
